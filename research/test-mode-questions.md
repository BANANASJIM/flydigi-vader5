# 测试模式逆向待确认问题

## 0. 初始化序列 (2025-01-01 抓包确认)

**设备插入后，必须先完成以下握手才能发送测试模式命令：**

| # | CMD | 发送 (32字节) | 响应 | 说明 |
|---|-----|---------------|------|------|
| 1 | 0x01 | `5aa5010203` | `5aa50101...` | 设备信息查询 |
| 2 | 0xa1 | `5aa5a102a3` | `5aa5a101...` | MAC/序列号 |
| 3 | 0x02 | `5aa5020204` | `5aa50201...` | 配置读取 |
| 4 | 0x04 | `5aa5040206` | `5aa50401...` | 配置数据 |
| 5 | 0x11 | `5aa51107ff00ffffff14` | `5aa51101...` | 确保测试模式关闭 |

**完整发送数据：**
```
CMD 0x01: 5aa5010203000000000000000000000000000000000000000000000000000000
CMD 0xa1: 5aa5a102a3000000000000000000000000000000000000000000000000000000
CMD 0x02: 5aa5020204000000000000000000000000000000000000000000000000000000
CMD 0x04: 5aa5040206000000000000000000000000000000000000000000000000000000
CMD 0x11: 5aa51107ff00ffffff1400000000000000000000000000000000000000000000
```

### 原始抓包数据 (2025-01-01 Linux usbmon)

#### Frame 4137: CMD 0x01 发送 (设备信息查询)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa5010203000000000000000000000000000000000000000000000000000000
```

#### Frame 4159: CMD 0x01 响应
```
USB URB: 1.48.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa50101008202000000000345010071310467351400000000000010261f000f
解析:
- 5a a5 01 01 - magic + cmd + status
- 00 82 02 00 - ?
- 00 00 00 03 45 01 00 - 版本信息?
- 71 31 04 67 35 14 - 序列号/设备ID
```

#### Frame 4169: CMD 0xa1 发送 (MAC/序列号)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa5a102a3000000000000000000000000000000000000000000000000000000
```

#### Frame 4196: CMD 0xa1 响应
```
USB URB: 1.48.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa5a101000075125053d96effffffffffffffffffff00000000000000000009
解析:
- 5a a5 a1 01 - magic + cmd + status
- 00 00 75 12 50 53 d9 6e - MAC地址或序列号
- ff ff ff ff ff ff ff ff ff ff - 空白区域
```

#### Frame 4215: CMD 0x02 发送 (配置读取)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa5020204000000000000000000000000000000000000000000000000000000
```

#### Frame 4225: CMD 0x02 响应
```
USB URB: 1.48.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa5020100ffffffffffffffffffffffffffffffffffffffffffffffffffffe9
解析:
- 5a a5 02 01 - magic + cmd + status
- 00 ff ff ff... - 全 0xff = 空/默认配置
- e9 - 校验和
```

#### Frame 4227: CMD 0x04 发送 (配置数据)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa5040206000000000000000000000000000000000000000000000000000000
```

#### Frame 4237: CMD 0x04 响应
```
USB URB: 1.48.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa504010014206e7a1c0000000022074c0000000000000000000000000000b2
解析:
- 5a a5 04 01 - magic + cmd + status
- 00 14 20 6e 7a 1c... - 配置数据
- b2 - 校验和
```

#### Frame 4455: CMD 0x11 发送 (测试模式关闭)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa51107ff00ffffff1400000000000000000000000000000000000000000000
```

#### Frame 4463: CMD 0x11 响应
```
USB URB: 1.48.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa5110100010000001400000000000000000000000000000000000000000027
解析:
- 5a a5 11 01 - magic + cmd + status
- 00 01 00 00 00 14 - 当前状态 (14 = normal mode)
- 27 - 校验和
```

#### Frame 4857: CMD 0x11 发送 (软件持续发送)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa51107ff00ffffff1400000000000000000000000000000000000000000000
```

### 切换板载配置 (Profile) 命令 (2025-01-01 抓包)

#### Frame 222159: CMD 0xa2 发送 (切换到 profile 2)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa5a20301a60000000000000000000000000000000000000000000000000000
解析:
- 5a a5 - magic
- a2 - 命令 (切换配置)
- 03 - 长度
- 01 - slot index (0-based: 00=profile1, 01=profile2, 02=profile3)
- a6 - 校验和 (a2 + 03 + 01 = a6)
```

#### Frame 222171: CMD 0xa2 响应
```
USB URB: 1.48.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa5a20100a60000000000000000000000000000000000000000000000000049
解析:
- 5a a5 a2 01 - magic + cmd + status (01 = success)
- 00 a6 - 当前 slot
- 49 - 校验和
```

#### Frame 222327: CMD 0x11 发送 (切换后关闭测试模式)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa51107ff00ffffff1400000000000000000000000000000000000000000000
```

#### Frame 222335: CMD 0x11 响应
```
USB URB: 1.48.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa5110100010000001400000000000000000000000000000000000000000027
```

### EP2 IN 预读取 (2026-01-01 抓包)

**关键发现**: Windows 驱动在发送任何 EP6 命令之前，会先读取 EP2 IN 清空设备缓冲区。

设备可能保留上次会话状态，自动发送以下响应（无需命令触发）：

#### Frame 12756: 设备主动发送 CMD 0x04 响应
```
USB URB: 1.50.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa504010014206e7a1c0000000022074c0000000000000000000000000000b2
解析:
- 5a a5 04 01 - magic + cmd + status (01=成功)
- 00 14 20 6e 7a 1c... - 配置数据
- b2 - 校验和
```

#### Frame 12759: 设备主动发送 CMD 0x11 响应
```
USB URB: 1.50.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa5110100010100001500000000000000000000000000000000000000000029
解析:
- 5a a5 11 01 - magic + cmd + status (01=成功)
- 00 01 01 00 00 15 - 测试模式状态 (0x15 = 测试模式开)
- 29 - 校验和
```

**注意**: Host 发送了 10 次相同的 EP2 IN 读取请求来清空缓冲区，然后才发送 EP6 OUT 命令。

### 振动测试命令 (2026-01-01 抓包)

#### Frame 524853: CMD 0x12 发送 (振动测试)
```
USB URB: host → 1.48.6, EP6 OUT, URB_INTERRUPT, 32 bytes
HID Data: 5aa5120600000000000000000000000000000000000000000000000000000000
解析:
- 5a a5 - magic
- 12 - 命令 (振动测试)
- 06 - 长度
- 00 00 - 左右马达强度 (00 00 = 关闭)
```

#### Frame 524867: CMD 0x12 响应
```
USB URB: 1.48.2 → host, EP2 IN (0x82), URB_INTERRUPT, 32 bytes
HID Data: 5aa5120100000000000000000000000000000000000000000000000000000013
解析:
- 5a a5 12 01 - magic + cmd + status (01=成功)
- 00 00 00... - 填充
- 13 - 校验和
```

## 1. 测试模式命令

- [x] 命令格式：`5a a5 11 07 ff 01 ff ff ff 15 00...` ✓
- [x] 发送接口：Interface 1 / EP6 OUT ✓
- [x] 包长度：32 字节 (不是 64!) ✓
- [x] 控制器回显相同命令 ✓
- [x] **需要先完成初始化握手** ✓

## 2. 扩展按键数据来源

- [x] 数据来自 Interface 2 / **EP2 IN** (不是 EP3) ✓
- [x] Magic bytes：`5a a5 ef` ✓
- [x] 数据包长度：32 字节 ✓
- [x] 按键偏移：byte[13] 和 byte[14] ✓

## 3. HID vs USB

- [ ] **待验证**: hidraw 能否读取 Interface 2 数据？
- [ ] 如果不能，需改用 libusb 直接读 EP2 (0x82)

## 4. 时序

- [x] 测试模式命令后立即返回扩展数据 (Wireshark 确认)

---

## 测试结果

### 2024-12-31 测试

**发送测试模式命令:**
```
5a a5 11 07 ff 01 ff ff ff 15 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

**EP6 (Interface 1) 返回:**
```
5a a5 11 07 ff 01 ff ff ff 15 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

**EP2 IN (Interface 2) 返回扩展按键数据:**

无按键:
```
5a a5 ef 08 00 f8 ff 30 00 18 00 00 00 00 00 00 00 03 00 d4 ff f0 ff 17 ff 74 ef 7a 17 74 00 00
```

按住 M1:
```
5a a5 ef f4 ff 0c 00 f4 ff f0 ff 00 00 04 00 00 00 a5 ff 3c 00 37 00 96 f6 0c 0a 5a 0b 98 00 00
                                       ^^
                                       04 = M1 (bit 2)
```

### EP2 报告结构 (32 字节)

EP2 是原始完整输入报告，包含所有按键和传感器数据：

```
Offset  Size  Description
------  ----  -----------
0-2     3     Magic (5a a5 ef)
3-4     2     左摇杆 X (int16 LE) ✓
5-6     2     左摇杆 Y (int16 LE) ✓
7-8     2     右摇杆 X (int16 LE) ✓
9-10    2     右摇杆 Y (int16 LE) ✓
11-12   2     普通按键 (见下表)
13      1     扩展按键1: C(0) Z(1) M1(2) M2(3) M3(4) M4(5) LM(6) RM(7)
14      1     扩展按键2: O(0) Home(3)
15      1     LT 模拟值 (0-255) ✓
16      1     RT 模拟值 (0-255) ✓
17-18   2     陀螺仪 X (int16 LE, roll)
19-20   2     陀螺仪 Y (int16 LE, pitch)
21-22   2     陀螺仪 Z (int16 LE, yaw)
23-24   2     加速度 X (int16 LE, 左-, 右+)
25-26   2     加速度 Y (int16 LE, 后-, 前+)
27-28   2     加速度 Z (int16 LE, 下-, 上+)
29      1     计数器
30-31   2     保留

IMU 缩放: 4096 LSB/g (加速度计)
```

### 普通按键编码 (byte[11-12])

扩展报告中普通按键的编码与 Interface 0 不同:

| 按键 | Offset | 值 | Bit |
|------|--------|-----|-----|
| Dpad Up | byte[11] | 0x01 | bit 0 |
| Dpad Right | byte[11] | 0x02 | bit 1 |
| Dpad Down | byte[11] | 0x04 | bit 2 |
| Dpad Left | byte[11] | 0x08 | bit 3 |
| A | byte[11] | 0x10 | bit 4 |
| B | byte[11] | 0x20 | bit 5 |
| Select | byte[11] | 0x40 | bit 6 |
| X | byte[11] | 0x80 | bit 7 |
| Y | byte[12] | 0x01 | bit 0 |
| Start | byte[12] | 0x02 | bit 1 |
| LB | byte[12] | 0x04 | bit 2 |
| RB | byte[12] | 0x08 | bit 3 |
| LT | byte[12] | 0x10 | bit 4 |
| RT | byte[12] | 0x20 | bit 5 |
| L3 | byte[12] | 0x40 | bit 6 |
| R3 | byte[12] | 0x80 | bit 7 |
| O | byte[14] | 0x01 | bit 0 |
| Home | byte[14] | 0x08 | bit 3 |

模拟值:
| 输入 | Offset | 范围 |
|------|--------|------|
| LT | byte[15] | 0-255 |
| RT | byte[16] | 0-255 |

扩展按键 byte[13] ✓:
| 按键 | 值 | Bit |
|------|-----|-----|
| C | 0x01 | bit 0 |
| Z | 0x02 | bit 1 |
| M1 | 0x04 | bit 2 |
| M2 | 0x08 | bit 3 |
| M3 | 0x10 | bit 4 |
| M4 | 0x20 | bit 5 |
| LM | 0x40 | bit 6 |
| RM | 0x80 | bit 7 |

原始数据:
```
Dpad上: 5aa5ef0000000000000000010000000000feff020001000500f8fffa0f3d0000
                      ^^
                   byte[11]=0x01 (bit 0)
Dpad右: 5aa5ef00000000000000000200000000000100010001000600fdfffc0fdb0000
                      ^^
                   byte[11]=0x02 (bit 1)
Dpad下: 5aa5ef000000000000000004000000000000000100ffff060004000510fc0000
                      ^^
                   byte[11]=0x04 (bit 2)
Dpad左: 5aa5ef0000000000000000080000000000feff000000000a00fcff0410af0000
                      ^^
                   byte[11]=0x08 (bit 3)
A:      5aa5ef0000000018002400100000000000efff0200feffebffe00f7e07100000
                         ^^
B:      5aa5ef2c00800018fe70ff20000000000009000300feffe3ff43109506ba0000
                         ^^
X:      5aa5ef00000000e8ffdcff8000000000000b000000feff1b0005109e07480000
                         ^^
Y:      5aa5ef00000000f8fff4ff000100000000b9ff01000500e9ff750ec9096f0000
                            ^^
Start:  5aa5efe0ffd0ff48004c000002000000000600ffffffffb4536c0f9408ee0000
                            ^^
Select: 5aa5ef0000000000000000400000000000f4ffffff020042ac51bb220e420000
                         ^^
LB:     5aa5ef28002800f0fff8ff00040000000009001600e1ffdd09e309aa09140000
                            ^^
RB:     5aa5ef0000000080fffcff000800000000fcff0000ffffecff06102d07100000
                            ^^
M4:     5aa5ef0800c4fff8fffcff000020000000d1ff12000b00b6fb900e8808dc0000
                               ^^
Home:   5aa5ef10003c00ccffd8ff0000000800000f000000ffffebffc40fb507690000
                            ^^
LT:     5aa5ef000000000000fcff00100000ff00e9fff9ff02006efdb7083b0e0b0000
                            ^^          ^^
                         byte[12]=0x10  byte[15]=0xff (模拟值)
RT:     5aa5ef00000000000000000020000000ffccff01000100a2011b104a08ee0000
                            ^^          ^^
                         byte[12]=0x20  byte[16]=0xff (模拟值)
L3:     5aa5ef30e86407b8ffbcff00400000000003000000faff79fe7b059c0f950000
                            ^^
                         byte[12]=0x40
R3:     5aa5ef240014004c1550e8008000000000050000000100f7ffd30fa307de0000
                            ^^
                         byte[12]=0x80
```

左摇杆往前推:
```
5a a5 ef 10 00 ff 7f f4 ff 14 00 00 00 00 00 00 00 f8 ff 01 00 00 00 c7 f5 65 0b 97 12 43 00 00
```

左摇杆向右推:
```
5a a5 ef ff 7f bc fd d0 ff f8 ff 00 00 00 00 00 00 01 00 ff ff ff ff 09 ff 5f 02 c0 10 31 00 00
```

右摇杆向右推:
```
5a a5 ef 60 00 40 00 ff 7f 08 eb 00 00 00 00 00 00 fa ff 13 00 e2 ff 74 05 c5 05 7a 11 a9 00 00
```

右摇杆向上推:
```
5a a5 ef c8 ff c4 ff dc 0b ff 7f 00 00 00 00 00 00 e1 ff e3 ff f7 ff de 03 17 06 ae 11 32 00 00
```

按住 X 键:
```
5a a5 ef dc ff dc ff 00 00 00 00 10 00 00 00 00 00 48 00 e9 ff b7 ff 71 05 16 f7 dc 10 7c 00 00
```

按住 A 键 (样本1):
```
5a a5 ef d8 ff e0 ff 24 00 10 00 10 00 00 00 00 00 27 00 38 00 ce ff 38 03 89 ff 73 10 52 00 00
```

按住 A 键 (样本2):
```
5a a5 ef f0 ff fc ff 1c 00 2c 00 10 00 00 00 00 00 05 00 00 00 fa ff e3 04 6d ff f6 0f 88 00 00
```

按住 B 键:
```
5a a5 ef e0 ff d4 ff 14 00 10 00 20 00 00 00 00 00 02 00 1f 00 06 00 a5 0a 5f 00 ab 0c 73 00 00
```

方向下 (D-pad Down):
```
5a a5 ef 08 00 00 00 ec ff e0 ff 04 00 00 00 00 00 09 00 16 00 ff ff b9 05 32 ff c2 0f 47 00 00
```

**结论:**
- [x] **EP2 IN** (不是 EP3) 返回扩展按键数据
- [x] Magic bytes: `5a a5 ef` 确认
- [x] byte[13] = 扩展按键 (M1-M4, C, Z, LM, RM)
- [x] byte[11] = 普通按键? (X = bit 4)
- [ ] byte[5-6] 可能是摇杆 Y 而非陀螺仪？待进一步测试

---

## Debug TUI 为什么读不到扩展按键？

### 问题分析

Wireshark 在 USB 层捕获到 EP2 数据，但 debug.cpp 的 hidraw 读取没有反应。

**原因分析：**

1. **Wireshark vs Hidraw 层级不同**
   - Wireshark 捕获 USB 层原始数据
   - hidraw 依赖内核 HID 驱动解析 HID 报告描述符

2. **可能问题：Interface 2 的 HID 描述符**
   - 厂商自定义数据 `5a a5 ef...` 可能不符合 HID 报告描述符
   - 内核可能丢弃或过滤不匹配的数据

3. **代码问题：O_NONBLOCK**
   ```cpp
   // hidraw.cpp:85
   const int fd = ::open(dev_path->c_str(), O_RDWR | O_NONBLOCK);
   ```
   非阻塞模式下 read() 无数据时返回 EAGAIN，线程空转

### 验证步骤

1. **检查 hidraw 是否收到数据** (在主机上执行)
   ```bash
   # 启用测试模式后
   sudo cat /dev/hidrawX | xxd | head -10
   ```
   (X = Interface 2 对应的 hidraw 设备号)

2. **如果 hidraw 没有数据**
   - 说明内核 HID 驱动未传递数据
   - 需要用 libusb 直接读取 EP2

3. **如果 hidraw 有数据**
   - 需要修复 O_NONBLOCK + poll/select 等待机制

### 下一步

如果 hidraw 读不到数据，需要修改实现：
- 用 UsbTransport 打开 Interface 2
- 用 libusb 直接读取 EP2 (0x82)

---

## 键位修改协议 (EP6 OUT)

### Remap 完整时序 (2024-12-31 抓包)

```
1. Host → EP6:  5a a5 11 07 ff 01 ff ff ff 15 00...  (测试模式开启)
2. Device → EP2: 5a a5 11 01 00 01 01 00 00 15 00...29  (持续发送状态响应)
3. Device → EP2: 5a a5 ef 00 00 00 00 00 00 00 00 20 00...  (切换到扩展报告)
4. Host → EP6:  5a a5 11 07 ff 00 ff ff ff 14 00...  (测试模式关闭)
5. Device → EP2: 5a a5 ef 00 00 00 00 00 00 00 00 20 00...  (继续扩展报告)
6. Host → EP6:  5a a5 a4 06 01 03 01 14 c3 00...  (发送 remap 命令)
```

**新发现:**
- `5a a5 11 01` = 设备对测试模式命令的状态响应 (不是 `5a a5 ef`)
- 设备先持续发送 `11 01` 响应，然后切换到 `ef` 扩展报告
- Remap 命令 (a4 06) 在**关闭**测试模式后发送

### 抓包数据: C → A (完整流程)

```
1. Host → EP6:   5a a5 11 07 ff 01 ff ff ff 15 00...     (开启测试模式)
2. Device → EP2: 5a a5 ef c4 ff f8 ff 00 00 00 00 10 00... (等待按键确认)
3. Host → EP6:   5a a5 11 07 ff 00 ff ff ff 14 00...     (关闭测试模式)
4. Device → EP2: 5a a5 ef c4 ff f8 ff 00 00 00 00 10 00... (继续扩展报告)
5. Host → EP6:   5a a5 11 07 ff 00 ff ff ff 14 00...     (再次关闭)
6. Host → EP6:   5a a5 a4 06 01 03 01 14 c3 00...        (a4 06 命令)
7. Device → EP2: 5a a5 11 01 00 01 00 00 00 14 00...27   (11 01 响应)
8. Host → EP6:   5a a5 a4 01 00 00 01 14 c3 00...7d      (a4 01 命令)
9. Host → EP6:   5a a5 a5 17 00 00 04 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff ba 00...
                                   ^^ C→A(04)
10. Device → EP2: 5a a5 a5 01 00 00 04 00 00 ff...ba...5e  (a5 回显)
11. Host → EP6:   5a a5 a6 04 50 53 4d 00...              (保存, "PSM")
12. Device → EP2: 5a a5 a6 01 00 53 4d 00...47            (a6 响应)
```

**新发现:**
- a4 有两种: **a4 06** (发起) 和 **a4 01** (确认?)
- a5 17 响应: **a5 01** (设备回显配置)
- a6 04 响应: **a6 01**
- a6 04 的 byte[4-6] = `50 53 4d` = **"PSM"** (ASCII magic，不是校验和!)

### 抓包数据: M1 → B

```
5a a5 a5 17 00 00 ff 00 00 ff 00 00 05 00 00 04 00 00 05 00 00 ff 00 00 ff c6 00...
                                    ^^ M1→B(05)
```

### 抓包数据: M1 → RT (完整流程)

```
发: 5a a5 11 07 ff 01 ff ff ff 15 00...                    (开启测试模式)
收: 5a a5 ef 00 00 00 00 24 00 30 00 00 20 00 00 00 4c 0f 00 98 ff 30 00 1c 02 8d 0f a1 08 20 00 00
发: 5a a5 11 07 ff 00 ff ff ff 14 00...                    (关闭测试模式)
收: 5a a5 ef 00 00 00 00 24 00 30 00 00 20 00 00 00 da 1d 00 82 ff 31 00 26 02 77 0f ab 08 26 00 00
发: 5a a5 11 07 ff 00 ff ff ff 14 00...                    (再次关闭)
收: 5a a5 ef 00 00 00 00 24 00 30 00 00 20 00 00 00 ff 1d 00 82 ff 31 00 26 02 77 0f ab 08 28 00 00
发: 5a a5 a4 06 02 03 01 14 c4 00...                       (a4 06, slot=2)
收: 5a a5 11 01 00 01 00 00 00 14 00...27                  (11 01 响应)
发: 5a a5 a4 01 00 00 01 14 c4 00...7e                     (a4 01 确认)
发: 5a a5 a5 17 00 00 ff 00 00 ff 00 00 0d 00 00 ff 00 00 ff 00 00 ff 00 00 ff c3 00...
                                       ^^ M1→RT(0d)
收: 5a a5 a5 01 00 00 ff 00 00 ff 00 00 0d 00 00 ff 00 00 ff 00 00 ff 00 00 ff c3 00...70
发: 5a a5 a6 04 10 f9 b3 00...                             (保存)
收: 5a a5 a6 01 00 f9 b3 00...53                           (a6 响应)
```

**确认:**
- a4 06 byte[4] = 源按键槽位 (0-based): 0=C, 1=Z, **2=M1**
- RT = 0x0d
- a6 04 byte[4-6] 不是固定值 (这里是 `10 f9 b3`)

### 抓包数据: Z → B (完整)

```
收: 5a a5 ef 00 00 00 00 00 00 00 00 00 20 00 00 00 00 00 2a 00 28 00 34 00 29 01 ab 0d 33 0b 50 00 00
发: 5a a5 11 07 ff 00 ff ff ff 14 00...                    (关闭测试模式)
发: 5a a5 11 07 ff 00 ff ff ff 14 00...                    (再次关闭)
收: 5a a5 ef 00 00 00 00 00 00 00 00 00 20 00 00 00 00 00 03 00 46 00 48 00 23 01 bf 0d 21 0b 54 00 00
发: 5a a5 a4 06 02 03 01 14 c4 00...                       (a4 06, byte[4]=02)
发: 5a a5 a5 17 00 00 ff 00 00 05 00 00 0d 00 00 ff 00 00 ff 00 00 ff 00 00 ff c9 00...
                               ^^ Z→B(05)   ^^ M1→RT(0d)保留
收: 5a a5 a5 01 00 00 ff 00 00 05 00 00 0d 00 00 ff 00 00 ff 00 00 ff 00 00 ff c9 00...7c
发: 5a a5 a6 04 61 d3 de 00...                             (保存)
收: 5a a5 a6 01 00 d3 de 00...58                           (a6 响应)
```

**关键发现:**
- a5 17 slot1 = 05 (B) ✓ 确认 Z 在 slot1
- a4 06 byte[4] = 02，与槽位索引不一致 → **a4 06 不是槽位索引!**
- a6 04 byte[4-6] = `61 d3 de` (又一个新值)

### 抓包数据: M3 → Y (部分)

```
收: 5a a5 ef 00 00 00 00 38 00 34 00 00 01 00 00 00 00 6b ff 0f 00 8c 00 00 ff 9d 0d 03 0b 15 00 00
发: 5a a5 11 07 ff 00 ff ff ff 14 00...                    (关闭测试模式)
发: 5a a5 11 07 ff 00 ff ff ff 14 00...                    (再次关闭)
发: 5a a5 a4 06 02 03 01 14 c4 00...                       (a4 06, byte[4]=02 ← 和 Z、M1 相同!)
发: 5a a5 a4 01 00 00 01 14 c4 00...7e                     (a4 01)
发: 5a a5 a5 17 00 00 ff 00 00 05 00 00 0d 00 00 ff 00 00 08 00 00 ff 00 00 ff d2 00...
                               ^^ Z   ^^ M1  ^^ M2无 ^^ M3→Y(08)
收: 5a a5 a5 01 00 00 ff 00 00 05 00 00 0d 00 00 ff 00 00 08 00 00 ff 00 00 ff d2 00...8e
发: 5a a5 a6 04 d9 6e f1 00...                             (保存)
收: 5a a5 a6 01 00 6e f1 00...06                           (a6 响应)
```

**确认:**
- **a4 06 byte[4] = 02 是固定值!** (Z、M1、M3 都是 02)
- slot4 (M3) = 08 → Y (用户确认)
- a6 04 byte[4-6] = `d9 6e f1`

### 命令解析

#### a4 06 - Remap 命令
```
5a a5 a4 06 01 03 01 14 c3
0  1  2  3  4  5  6  7  8

待确认 (与 protocol-24g.md 编码不一致):
- protocol-24g.md: M1=index 2, B=05
- 抓包数据: byte[5]=03, byte[7]=14
- 可能索引是 1-based? (M1=3 而非 2)
- 0x14=20, 需要更多样本确认

注: a5 17 命令明确显示 slot2=05(B)，与 protocol-24g.md 一致
可能 a4 06 用了不同的编码方式
```

#### a5 17 - 批量配置命令
```
5a a5 a5 17 00 00 ff 00 00 ff 00 00 05 00 00 04 00 00 05 00 00 ff 00 00 ff c6
            ~~~~~~~ ~~~~~~~ ~~~~~~~ ~~~~~~~ ~~~~~~~ ~~~~~~~ ~~~~~~~
            slot0   slot1   slot2   slot3   slot4   slot5   slot6

解析 (3 字节一组):
slot0 (C):  00 00 ff → 未映射
slot1 (Z):  00 00 ff → 未映射
slot2 (M1): 00 00 05 → 映射到 B (05) ← 本次新增
slot3 (M2): 00 00 04 → 映射到 A (04) ← 之前配置
slot4 (M3): 00 00 05 → 映射到 B (05) ← 之前配置
slot5 (M4): 00 00 ff → 未映射
slot6 (LM): 00 00 ff → 未映射
```
- 批量命令：每次发送完整配置，包含所有映射
- 每组 3 字节，最后字节是目标按键
- ff = 未映射
- 前两字节待确认 (可能是修饰键或触发模式?)

#### a6 04 - 保存命令
```
C → A:    5a a5 a6 04 50 53 4d 00...  ("PSM")
M1 → RT:  5a a5 a6 04 10 f9 b3 00...
Z → B:    5a a5 a6 04 61 d3 de 00...
M3 → Y:   5a a5 a6 04 d9 6e f1 00...
```
- byte[4-6] 每次不同，计算方式未知
- 设备响应: `5a a5 a6 01 00 XX XX 00...`

#### 目标按键编码 (已确认)

| 值   | 按键 | 来源 |
|------|------|------|
| 04   | A    | C→A |
| 05   | B    | M1→B, Z→B |
| 08   | Y    | M3→Y |
| 0d   | RT   | M1→RT |
| ff   | 无映射 | - |

注: protocol-24g.md 写的 Y=07，但抓包显示 Y=08，待确认

---

## 协议总结

### 已确认 ✅

| 项目 | 值/格式 | 备注 |
|------|---------|------|
| 命令接口 | EP6 OUT (Interface 1) | 64字节 |
| 响应接口 | EP2 IN (Interface 2) | 32字节 |
| Magic | 5a a5 | 所有命令 |
| 校验和 | sum(byte[2:]) & 0xff | a5 17 确认 |
| 测试模式开 | 5a a5 11 07 ff 01 ff ff ff 15 | - |
| 测试模式关 | 5a a5 11 07 ff 00 ff ff ff 14 | - |
| a4 06 固定部分 | 5a a5 a4 06 XX 03 01 14 [sum] | XX见下 |
| a5 17 结构 | 7槽 × 3字节 + 校验和 | - |
| 响应规则 | 命令 XX YY → 响应 XX 01 | - |

### a5 17 槽位映射 ✅

| 槽位 | 偏移 | 源按键 |
|------|------|--------|
| 0 | byte[4-6] | C |
| 1 | byte[7-9] | Z |
| 2 | byte[10-12] | M1 |
| 3 | byte[13-15] | M2 |
| 4 | byte[16-18] | M3 |
| 5 | byte[19-21] | M4 |
| 6 | byte[22-24] | LM |

### 目标按键编码 ✅

| 值 | 按键 | 来源 |
|----|------|------|
| 04 | A | C→A 抓包 |
| 05 | B | M1→B, Z→B 抓包 |
| 08 | Y | M3→Y 抓包 |
| 0d | RT | M1→RT 抓包 |
| ff | 无映射 | - |

### 未确认 ❓

| 项目 | 已知值 | 问题 |
|------|--------|------|
| a4 06 byte[4] | C→A=01, 其他=02 | 01 vs 02 区别? |
| a6 04 byte[4-6] | 每次不同 | 计算方式未知 |
| a5 17 每槽前2字节 | 都是 00 00 | 用途? 修饰键? |
| X 编码 | ? | 06 或 07? |
| Y 编码 | 抓包=08 | protocol-24g.md 写 07 |
| RM/O 槽位 | ? | a5 17 只有7槽 |

### a6 04 样本

| 操作 | byte[4-6] |
|------|-----------|
| C → A | 50 53 4d ("PSM") |
| M1 → RT | 10 f9 b3 |
| Z → B | 61 d3 de |
| M3 → Y | d9 6e f1 |

### 简化实现建议

只需发送:
```
1. 5a a5 a5 17 [7槽配置] [校验和] 00...   设置映射
2. 5a a5 a6 04 [???] 00...                 保存 (byte[4-6] 需测试)
```

- a4 命令可能可以跳过 (UI 交互用)
- a6 04 byte[4-6] 可尝试固定值 00 00 00 或 50 53 4d